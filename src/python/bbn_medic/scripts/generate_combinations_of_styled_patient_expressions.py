import json
import os

from tqdm.auto import tqdm

from bbn_medic.common.Patient import PatientExpression
from bbn_medic.io.io_utils import JSONLGenerator, fopen
from bbn_medic.utils.logging_utils import setup_logger

"""
After templated AtomicPatientExpressions are restyled. We're at the stage of reassembling PatientExpression. There are
multiple choice here 1) Omit certain AtomicPatientExpression(I ate medication A but I chose not to tell you or I just 
forgot to tell you) 2) Include standard templated AtomicPatientExpression 3) Include restyled AtomPatientExpression.
The output of this program will 1) Tie to specific patient 2) Contains a combination of above three choices 3) will be 
prepend to the prompts generated by the LLM to serve as background information. 
"""

def dfs_create_patient_expression(standard_patient_expression, current_mover,
                                  standard_phrase_id_to_phrase,
                                  alternative_style_phrase_id_to_atomic_patient_expression, cur_buf,
                                  ret_buf,
                                  is_complete):
    if current_mover == len(standard_patient_expression.atomic_patient_expressions):
        ret_buf.append((list(i for i in cur_buf), is_complete))
    else:
        focus_standard_atomic_patient_expression = standard_patient_expression.atomic_patient_expressions[current_mover]
        focus_standard_atomic_patient_expression_phrase_id = focus_standard_atomic_patient_expression.meaning_id
        # Three choices here
        # Choice one: Include nothing
        dfs_create_patient_expression(standard_patient_expression, current_mover + 1,
                                      standard_phrase_id_to_phrase,
                                      alternative_style_phrase_id_to_atomic_patient_expression, cur_buf,
                                      ret_buf, False)
        # Choice two: Include standard
        for all_possible_replacement_patient_expression in standard_phrase_id_to_phrase[
            focus_standard_atomic_patient_expression_phrase_id]:
            cur_buf.append(all_possible_replacement_patient_expression)
            dfs_create_patient_expression(standard_patient_expression, current_mover + 1,
                                          standard_phrase_id_to_phrase,
                                          alternative_style_phrase_id_to_atomic_patient_expression, cur_buf,
                                          ret_buf,
                                          is_complete)
            cur_buf.pop()
        # Choice three: Include any of rephrase/restyled
        if alternative_style_phrase_id_to_atomic_patient_expression is not standard_phrase_id_to_phrase:
            for all_possible_replacement_patient_expression in alternative_style_phrase_id_to_atomic_patient_expression.get(
                    focus_standard_atomic_patient_expression_phrase_id,
                    ()):  # This key may be missing because restyling's output may be invalid and filtered.
                cur_buf.append(all_possible_replacement_patient_expression)
                dfs_create_patient_expression(standard_patient_expression, current_mover + 1,
                                              standard_phrase_id_to_phrase,
                                              alternative_style_phrase_id_to_atomic_patient_expression, cur_buf,
                                              ret_buf,
                                              is_complete)
                cur_buf.pop()


def write_patient_expression(wfp, deduplicate_set, standard_patient_expression, atomic_patient_expressions,
                             is_complete):
    patient_expression = PatientExpression(patient_id=standard_patient_expression.patient_id,
                                           atomic_patient_expressions=atomic_patient_expressions,
                                           is_complete=is_complete,
                                           complete_meaning_id=standard_patient_expression.complete_meaning_id)
    if patient_expression.text not in deduplicate_set:
        deduplicate_set.add(patient_expression.text)
        if len(patient_expression.text.strip()) > 0:
            wfp.write(f"{json.dumps(patient_expression.model_dump(), ensure_ascii=False, sort_keys=True)}\n")


def main(standard_patient_expression_path, restyled_atomic_patient_expression_path, output_path):
    standard_patient_expressions = JSONLGenerator.read_all(standard_patient_expression_path)
    restyled_atomic_patient_expressions = JSONLGenerator.read_all(restyled_atomic_patient_expression_path)
    standard_phrase_id_to_phrase = dict()
    style_to_phrase_id_to_phrase = dict()
    for standard_patient_expression in standard_patient_expressions:
        assert isinstance(standard_patient_expression, PatientExpression)
        for atomic_patient_expression in standard_patient_expression.atomic_patient_expressions:
            standard_phrase_id_to_phrase.setdefault(atomic_patient_expression.meaning_id, set()).add(
                atomic_patient_expression.strip_metadata())
    for restyled_atomic_patient_expression in restyled_atomic_patient_expressions:
        style_to_phrase_id_to_phrase.setdefault(restyled_atomic_patient_expression.style_id, dict()).setdefault(
            restyled_atomic_patient_expression.meaning_id, set()).add(restyled_atomic_patient_expression.strip_metadata())
    os.makedirs(os.path.dirname(output_path), exist_ok=True)
    memo_key_to_atomic_patient_expressions = dict()
    with fopen(output_path, 'w') as wfp:
        # There are two sources of duplication 1) phrase id used for generating permutation
        # of patient expression, and standard style patient expression have more than one duplicated phrase id due to rephrasing
        # 2) It's possible that after restyling we're seeing same output for the same meaning atomic patient expression
        for standard_patient_expression in tqdm(standard_patient_expressions):
            deduplicate_set = set()
            memo_key = f"{standard_patient_expression.meaning_id}|standard"
            if memo_key not in memo_key_to_atomic_patient_expressions:
                # In case there's no restyled patient expression.
                ret_buf = []
                dfs_create_patient_expression(standard_patient_expression, 0,
                                              standard_phrase_id_to_phrase, standard_phrase_id_to_phrase, [],
                                              ret_buf,
                                              True)
                memo_key_to_atomic_patient_expressions[memo_key] = sorted(ret_buf, key=lambda x: (x[1], len("".join(
                    j.text for j in x[0]))), reverse=True)
            for atomic_patient_expressions, is_complete in memo_key_to_atomic_patient_expressions[memo_key]:
                write_patient_expression(wfp, deduplicate_set, standard_patient_expression, atomic_patient_expressions,
                                         is_complete)
            for style in sorted(style_to_phrase_id_to_phrase.keys()):
                memo_key = f"{standard_patient_expression.meaning_id}|{style}"
                if memo_key not in memo_key_to_atomic_patient_expressions:
                    ret_buf = []
                    dfs_create_patient_expression(standard_patient_expression, 0,
                                                  standard_phrase_id_to_phrase, style_to_phrase_id_to_phrase[style], [],
                                                  ret_buf,
                                                  True)
                    memo_key_to_atomic_patient_expressions[memo_key] = sorted(ret_buf, key=lambda x: (x[1], len("".join(
                        j.text for j in x[0]))), reverse=True)
                for atomic_patient_expressions, is_complete in memo_key_to_atomic_patient_expressions[memo_key]:
                    write_patient_expression(wfp, deduplicate_set, standard_patient_expression,
                                             atomic_patient_expressions, is_complete)


if __name__ == "__main__":
    setup_logger()
    import argparse

    parser = argparse.ArgumentParser()
    parser.add_argument("--standard_patient_expression_path", type=str, required=True)
    parser.add_argument("--restyled_atomic_patient_expression_path", type=str, required=True)
    parser.add_argument("--output_path", type=str, required=True)
    args = parser.parse_args()
    main(args.standard_patient_expression_path, args.restyled_atomic_patient_expression_path, args.output_path)
